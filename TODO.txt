Modyfikacja main -> drugi main oddzielny dla Reversi

CPU

Stworzyć plik src/reversi.py
   - klasa Reversi dziedzicząca po klasie State z src/mcts.py
   - init - plansza 8x8, z 4 początkowymi pionkami
   - take_action_job - logika wykonywania ruchu, zamiana (odwrócenie) pionków. True/False czy ruch legalny
   - compute_outcome_job - czy gra się zakończyła, wynik (1, -1, 0) lub None jeśli gra trwa
   - take_random_action_playout - znajduje wszystkie legalne ruchy, wybiera losowy z nich
   - get_board - tablica numpy z planszą (do MCTS-NC)
   - get_extra_info - dodatkowe informacje o stanie gry (do MCTS-NC), jeśli potrzebne (NIE)
   - get_board_shape , get_max_actions , get_extra_info_memory_size - metody zwracające wartości

GPU
Zmodyfikować src/mctsnc_game_mechanics.py
    Dodać 5 funkcji Numba CUDA (@cuda.jit(device=True)):
    - is_action_legal_reversi - sprawdza czy ruch (jeden) jest legalny 
      w tym przypadku trzeba sprawdzić czy pole jest puste i czy ruch odwróci
        jakieś pionki przeciwnika (w 8 kierunkach)
    - take_action_reversi - wykonuje pojedynczy ruch na planszy:
        ustawia pionek na planszy i odwraca pionki przeciwnika
    - legal_actions_playout_reversi - znajduje wszystkie legalne ruchy dla danej planszy i 
    je do legal_actions_with_count
    - take_action_playout_reversi - wykonuje ruch na planszy podczas playoutu 
    - compute_outcome_reversi - sprawdza warunek końca gry i wynik 


Gra trwa do momentu aż nie będzie możliwy żaden ruch dla obu graczy:
    - jeśli plansza jest pełna lub
    - jeśli żaden z graczy nie może wykonać legalnego ruchu

Jeśli jeden z graczy nie może wykonać ruchu, tura przechodzi na drugiego gracza.
Funkcje take_action_job i take_random_action_playout muszą obsługiwać ten przypadek


Podmienić wywołania funkcji w mctsnc_game_mechanics.py na *_reversi


ruch o numerze 0 


is_action_legal
i 
take_action
